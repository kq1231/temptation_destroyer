<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><meta name="google-site-verification" content="SGGecsNNiCbhnC4w9xczIet6mJTTlOUDRwWISPWrV18"/><meta charset="UTF-8"/><meta name="og:site_name" content="Code With Andrea"/><link rel="canonical" href="https://codewithandrea.com/articles/robust-app-initialization-riverpod/"/><meta name="twitter:url" content="https://codewithandrea.com/articles/robust-app-initialization-riverpod/"/><meta name="og:url" content="https://codewithandrea.com/articles/robust-app-initialization-riverpod/"/><title>How to Build a Robust Flutter App Initialization Flow with Riverpod</title><meta name="twitter:title" property="og:title" content="How to Build a Robust Flutter App Initialization Flow with Riverpod"/><meta name="description" property="og:description" content="Some useful Riverpod techniques you can use to initialize async dependencies, show some loading UI, and handle errors during app startup."/><meta name="twitter:description" content="Some useful Riverpod techniques you can use to initialize async dependencies, show some loading UI, and handle errors during app startup."/><meta name="twitter:card" content="summary_large_image"/><link rel="stylesheet" href="/styles.min.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,400;0,700;0,900;1,400&family=Roboto+Mono&display=swap"/><link rel="shortcut icon" href="https://codewithandrea.com/img/favicon/favicon.ico" type="image/x-icon"/><link rel="apple-touch-icon" sizes="180x180" href="/img/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon/favicon-16x16.png"/><link rel="manifest" href="/img/favicon/site.webmanifest"/><link rel="mask-icon" href="/img/favicon/safari-pinned-tab.svg" color="#5bbad5"/><meta name="msapplication-TileColor" content="#da532c"/><meta name="theme-color" content="#ffffff"/><link rel="alternate" href="https://codewithandrea.com/rss.xml" type="application/rss+xml" title="Subscribe to Code With Andrea"/><meta name="twitter:image" content="https://codewithandrea.com/articles/robust-app-initialization-riverpod/images/twitter-card.png"/><meta name="image" property="og:image" content="https://codewithandrea.com/articles/robust-app-initialization-riverpod/images/twitter-card.png"/><script async defer data-domain="codewithandrea.com" src="https://plausible.io/js/script.tagged-events.outbound-links.revenue.js"></script><script>window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }</script><script src="/js/theme-toggle.min.js"></script><script src="/js/email-signup.min.js"></script><script src="/js/checkout.min.js"></script></head><body><header id="header"><div class="header-container"><a class="logo" href="/"><img src="/img/icons/logo.svg" alt="Code With Andrea"/><span>CODE WITH ANDREA</span></a><nav id="main-nav"><ul><li><a class="selected" href="/tutorials/">Tutorials</a></li><li><a href="/courses/">Courses</a></li><li><a href="/newsletter/">Newsletter</a></li><li class="switch-theme-list-item"><button class="switch-theme-button nav-button"><img class="icon-night-mode" width="22" height="22" src="/img/icons/icon-night-mode.svg" alt="Switch to night mode"/><img class="icon-day-mode" width="22" height="22" src="/img/icons/icon-day-mode.svg" alt="Day mode"/><span id="switch-theme-text">Switch to dark mode</span></button></li></ul><a class="search-link nav-button" href="/search/" aria-label="Search">  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path
          d="M10.875 18.75C15.2242 18.75 18.75 15.2242 18.75 10.875C18.75 6.52576 15.2242 3 10.875 3C6.52576 3 3 6.52576 3 10.875C3 15.2242 6.52576 18.75 10.875 18.75Z"
          stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M16.4434 16.4438L20.9997 21.0002" stroke="currentColor" stroke-width="1.5"
          stroke-linecap="round" stroke-linejoin="round" />
  </svg>        </a><button id="toggle-menu" class="nav-button">Menu</button><button class="switch-theme-button nav-button"><img class="icon-night-mode" width="22" height="22" src="/img/icons/icon-night-mode.svg" alt="Switch to night mode"/><img class="icon-day-mode" width="22" height="22" src="/img/icons/icon-day-mode.svg" alt="Day mode"/></button></nav></div></header><main class="article-container"><header><h1>How to Build a Robust Flutter App Initialization Flow with Riverpod</h1><div class="tags"><div class="tag tag-2"><a href="/tags/dart/">#dart</a></div><div class="tag tag-1"><a href="/tags/flutter/">#flutter</a></div><div class="tag tag-6"><a href="/tags/statemanagement/">#state-management</a></div><div class="tag tag-6"><a href="/tags/riverpod/">#riverpod</a></div></div><figure class="article-metadata-with-author updated"><picture><img src="/img/avatars/andrea-avatar-small.png" alt="Andrea Bizzotto"/></picture><figcaption><p class="author-name">Andrea Bizzotto</p><p class="article-details"><span><strong>Updated</strong>&nbsp;</span><time datetime="2024-12-02">Dec 2, 2024</time><span class="divider"></span><span>15 min read</span></p></figcaption></figure><a href="https://github.com/bizz84/starter_architecture_flutter_firebase" class="download-source-code" target="_blank" rel="noopener noreferrer"><svg width="18" height="20" viewBox="0 0 18 20" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M17.0247 5.69911L11.7811 0.455474C11.7736 0.447968 11.7654 0.441376 11.7577 0.434235C11.7475 0.424942 11.7377 0.415329 11.7271 0.406586C11.72 0.400818 11.7125 0.395782 11.7052 0.390243C11.693 0.38086 11.6808 0.371338 11.668 0.362686C11.6622 0.358795 11.656 0.355546 11.6502 0.351837C11.6353 0.342453 11.6204 0.333115 11.6049 0.324737C11.6006 0.322495 11.5963 0.320755 11.592 0.318603C11.5745 0.30954 11.5567 0.300842 11.5383 0.293197C11.5355 0.292006 11.5325 0.291134 11.5296 0.289993C11.5099 0.282073 11.4899 0.274657 11.4694 0.26843C11.4664 0.267514 11.4633 0.266965 11.4603 0.266095C11.44 0.260189 11.4195 0.254743 11.3984 0.250532C11.3917 0.249205 11.3848 0.24861 11.3781 0.247465C11.3607 0.244444 11.3434 0.241377 11.3257 0.239638C11.3008 0.237109 11.2758 0.235841 11.2507 0.23584H2.25C1.85231 0.236295 1.47105 0.394476 1.18984 0.675682C0.908636 0.956888 0.750455 1.33815 0.75 1.73584V18.2358C0.750455 18.6335 0.908636 19.0148 1.18984 19.296C1.47105 19.5772 1.85231 19.7354 2.25 19.7358H15.7507C16.1484 19.7354 16.5297 19.5772 16.8109 19.296C17.0921 19.0148 17.2503 18.6335 17.2507 18.2358V6.25035C17.2508 6.24545 17.2515 6.24074 17.2515 6.23584C17.2515 6.13575 17.2315 6.03667 17.1926 5.94447C17.1536 5.85227 17.0965 5.76883 17.0247 5.69911ZM12.1561 13.1412L9.53105 15.7662C9.5289 15.7684 9.52647 15.7702 9.52432 15.7723C9.50885 15.7874 9.49297 15.802 9.47626 15.8157C9.4671 15.8233 9.4574 15.8298 9.44797 15.8369C9.43781 15.8445 9.42783 15.8524 9.41725 15.8595C9.40636 15.8668 9.395 15.8731 9.38379 15.8798C9.37399 15.8856 9.36443 15.8918 9.35431 15.8972C9.34305 15.9032 9.33142 15.9083 9.31993 15.9138C9.30922 15.9188 9.29869 15.9242 9.28775 15.9287C9.27667 15.9333 9.26532 15.937 9.25406 15.941C9.24225 15.9453 9.23053 15.9498 9.21844 15.9535C9.20723 15.9569 9.19583 15.9594 9.18448 15.9622C9.17212 15.9653 9.15985 15.9688 9.14726 15.9713C9.13417 15.9739 9.12098 15.9754 9.10785 15.9773C9.09677 15.9789 9.08592 15.981 9.07475 15.9821C9.05013 15.9845 9.02545 15.9858 9.00073 15.9858C8.97601 15.9858 8.95134 15.9845 8.92671 15.9821C8.91554 15.981 8.90469 15.9789 8.89362 15.9773C8.88048 15.9754 8.8673 15.9739 8.85421 15.9713C8.84162 15.9688 8.82935 15.9653 8.81699 15.9622C8.80563 15.9594 8.79423 15.9569 8.78302 15.9535C8.77093 15.9498 8.75922 15.9453 8.74741 15.941C8.73614 15.937 8.72479 15.9333 8.71371 15.9287C8.70277 15.9242 8.69225 15.9188 8.68153 15.9138C8.67004 15.9083 8.65842 15.9032 8.64716 15.8972C8.63704 15.8918 8.62747 15.8856 8.61768 15.8798C8.60646 15.8731 8.59511 15.8668 8.58421 15.8595C8.57364 15.8524 8.56366 15.8445 8.5535 15.8369C8.54407 15.8298 8.53436 15.8233 8.52521 15.8157C8.50882 15.8023 8.49321 15.7879 8.47801 15.7731C8.47554 15.7707 8.47284 15.7686 8.47041 15.7662L5.84541 13.1412C5.70476 13.0006 5.62573 12.8098 5.62573 12.6109C5.62573 12.412 5.70474 12.2212 5.84539 12.0805C5.98604 11.9399 6.1768 11.8609 6.37571 11.8609C6.57463 11.8609 6.7654 11.9399 6.90605 12.0805L8.25073 13.4252V9.23584C8.25073 9.03693 8.32975 8.84616 8.4704 8.70551C8.61105 8.56486 8.80182 8.48584 9.00073 8.48584C9.19965 8.48584 9.39041 8.56486 9.53106 8.70551C9.67172 8.84616 9.75073 9.03693 9.75073 9.23584V13.4252L11.0954 12.0805C11.1651 12.0109 11.2477 11.9556 11.3387 11.9179C11.4297 11.8803 11.5273 11.8609 11.6257 11.8609C11.7242 11.8609 11.8218 11.8803 11.9128 11.918C12.0038 11.9557 12.0864 12.0109 12.1561 12.0805C12.2257 12.1502 12.281 12.2329 12.3187 12.3239C12.3563 12.4149 12.3757 12.5124 12.3757 12.6109C12.3757 12.7094 12.3563 12.8069 12.3186 12.8979C12.2809 12.9889 12.2257 13.0716 12.1561 13.1412V13.1412ZM11.2507 6.23584V2.04648L15.44 6.23584H11.2507Z" fill="#2E54FF"/>
</svg><span>Source code on GitHub</span></a></header><div><article><div class="content"><p>First impressions matterâ€”especially when users launch your Flutter app for the first time. A glitchy startup or a poor onboarding experience can frustrate users, leading to bad reviews or even uninstalls.</p><p>So, how do you ensure your app's startup code is rock-solid, handles errors gracefully, and scales to support features like deep links or URL-based navigation?</p><p>In this article, weâ€™ll start simple and build towards a robust, production-ready solution. Hereâ€™s the game plan:</p><ol><li><strong>Handling App Startup Errors inÂ <code>main</code></strong>: The basic (and naive) approach.</li><li><strong>Improved Error Handling with aÂ <code>StatefulWidget</code></strong>: Adding loading UI and retry functionality.</li><li><strong>Asynchronous Dependency Initialization with Riverpod</strong>: A more scalable solution.</li></ol><p>Weâ€™ll start by implementing aÂ <code>StatefulWidget</code>Â to display a loading UI while initializing the app. Youâ€™ll also learn how to handle errors and allow users to retry if something goes wrong.</p><p>Next, weâ€™ll exploreÂ <strong>eager provider initialization</strong>Â with Riverpod. This technique lets you preload dependencies asynchronously and access them synchronously later usingÂ <code>requireValue</code>.</p><p>Finally, weâ€™ll tweak the setup to ensure the flow supportsÂ <strong>URL navigation and deep links</strong>Â without breaking.</p><p>By the end, you'll have a robust app initialization strategy thatâ€™s ready for production. ğŸš€</p><p>Ready to dive in? Letâ€™s go! ğŸ‘‡</p><h2><a id="handling-app-startup-errors-the-basics" href="#handling-app-startup-errors-the-basics">Handling App Startup Errors: The Basics</a></h2><p>Letâ€™s start with a simple example:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">await</span><span class="w"> </span><span class="n">someAsyncCodeThatMayThrow</span><span class="p">();</span>
<span class="w">  </span><span class="n">runApp</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MaterialApp</span><span class="p">(</span><span class="nl">home:</span><span class="w"> </span><span class="n">MainApp</span><span class="p">()));</span>
<span class="p">}</span>
</div></code></pre><p>What happens if the code above throws an exception?</p><p>The app willÂ <strong>fail to callÂ <code>runApp</code></strong>Â and end up stuck on the splash screenâ€”leaving your users confused and frustrated. Ouch! ğŸ˜±</p><p>To improve this slightly, we can wrap the code in aÂ <code>try-catch</code>Â block:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">await</span><span class="w"> </span><span class="n">someAsyncCodeThatMayThrow</span><span class="p">();</span>
<span class="w">    </span><span class="n">runApp</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MaterialApp</span><span class="p">(</span><span class="nl">home:</span><span class="w"> </span><span class="n">MainApp</span><span class="p">()));</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">st</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// TODO: register the global error handlers: https://docs.flutter.dev/testing/errors</span>
<span class="w">    </span><span class="n">log</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">toString</span><span class="p">(),</span><span class="w"> </span><span class="nl">stackTrace:</span><span class="w"> </span><span class="n">st</span><span class="p">);</span>
<span class="w">    </span><span class="n">runApp</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MaterialApp</span><span class="p">(</span><span class="nl">home:</span><span class="w"> </span><span class="n">AppStartupErrorWidget</span><span class="p">(</span><span class="n">e</span><span class="p">)));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Now, if something goes wrong, we log the error and show anÂ <code>AppStartupErrorWidget</code>Â with an appropriate error message. This provides some feedback to the user instead of just hanging on the splash screen.</p><h3><a id="the-limitation" href="#the-limitation">The Limitation</a></h3><p>While this approach is better than nothing, itâ€™s still far from ideal. Why? Because it doesnâ€™t allow the user toÂ <strong>retry</strong>. If the startup process fails, the only option is to close and restart the appâ€”a frustrating experience.</p><p>Letâ€™s see how we can improve on this!</p><h2><a id="improved-error-handling-with-a-statefulwidget" href="#improved-error-handling-with-a-statefulwidget">Improved Error Handling with a StatefulWidget</a></h2><p>To enhance the user experience, letâ€™s tackle a few key requirements for app startup:</p><ul><li>Display aÂ <strong>loading screen</strong>Â during initialization.</li><li>If initialization fails, show anÂ <strong>error message</strong>Â with a â€œRetryâ€ button.</li><li>If initialization succeeds, show theÂ <strong>main app UI</strong>.</li></ul><p>We can handle these scenariosâ€”<strong>loading</strong>,Â <strong>error</strong>, andÂ <strong>success</strong>â€”by creating a customÂ <code>StatefulWidget</code>Â calledÂ <code>AppStartupWidget</code>. This widget will encapsulate the app initialization logic and manage the different UI states.</p><figure><picture><source srcset="images/widget-subtrees.webp 2x" type="image/webp"/><img class="bottom-12px" alt="A diagram showing the various widget trees loaded at different stages of the app startup process" srcset="images/widget-subtrees.png 2x"/></picture><figcaption><center><i>A diagram showing the various widget trees loaded at different stages of the app startup process</i></center></figcaption></figure><h3><a id="implementation" href="#implementation">Implementation</a></h3><p>Hereâ€™s a basic structure forÂ <code>AppStartupWidget</code>:</p><pre><code><div class="highlight"><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">AppStartupWidget</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">StatefulWidget</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">AppStartupWidget</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">});</span>

<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="n">State</span><span class="o">&lt;</span><span class="n">AppStartupWidget</span><span class="o">&gt;</span><span class="w"> </span><span class="n">createState</span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">_AppStartupWidgetState</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">class</span><span class="w"> </span><span class="nc">_AppStartupWidgetState</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">State</span><span class="o">&lt;</span><span class="n">AppStartupWidget</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// declare state variables</span>

<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">initState</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">unawaited</span><span class="p">(</span><span class="n">initializeDependencies</span><span class="p">());</span>
<span class="w">    </span><span class="k">super</span><span class="p">.</span><span class="n">initState</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">initializeDependencies</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// async initialization</span>
<span class="w">      </span><span class="kd">await</span><span class="w"> </span><span class="n">someAsyncCodeThatMayThrow</span><span class="p">();</span>
<span class="w">      </span><span class="c1">// TODO: set success state</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// TODO: set error state</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="n">Widget</span><span class="w"> </span><span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span><span class="w"> </span><span class="n">context</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * if (success) return MainApp()</span>
<span class="cm">     * if (loading) return AppStartupLoadingWidget()</span>
<span class="cm">     * if (error) return AppStartupErrorWidget(error, onRetry: () { ... })</span>
<span class="cm">     */</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>With this widget in place, we can simplify theÂ <code>main()</code>Â method to:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">runApp</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MaterialApp</span><span class="p">(</span><span class="nl">home:</span><span class="w"> </span><span class="n">AppStartupWidget</span><span class="p">()));</span>
<span class="p">}</span>
</div></code></pre><h3><a id="next-steps" href="#next-steps">Next Steps</a></h3><p>To fully flesh out this widget, we could:</p><ol><li><strong>Model the states</strong>: Use a sealed class or an enumeration to represent the three states (<code>Loading</code>,Â <code>Error</code>, andÂ <code>Success</code>).</li><li><strong>Handle async logic</strong>: PopulateÂ <code>initializeDependencies()</code>Â with our async initialization code and update the state accordingly.</li><li><strong>Switch between states in the UI</strong>: Use aÂ <code>switch</code>Â expression in theÂ <code>build()</code>Â method to render the appropriate widget for each state.</li><li><strong>Add retry functionality</strong>: Provide a callback in the error state to retry initialization.</li></ol><p>While this approach works well for stateful initialization, itâ€™s not sufficient if your app needs to initialize dependencies and make them easily accessible throughout the app. For that, we need to leverage a <strong>dependency injection framework</strong> or a <strong>service locator</strong>.</p><p>This is whereÂ <strong>Riverpod</strong>Â comes into play. Letâ€™s see how it can help us manage dependencies asynchronously. ğŸ‘‡</p><h2><a id="asynchronous-dependency-initialization-with-riverpod" href="#asynchronous-dependency-initialization-with-riverpod">Asynchronous Dependency Initialization with Riverpod</a></h2><p>Previously, we used this simple initialization code:</p><pre><code><div class="highlight"><span></span><span class="kd">await</span><span class="w"> </span><span class="n">someAsyncCodeThatMayThrow</span><span class="p">();</span>
</div></code></pre><p>But in a real-world app, you'll likely have dependencies that need to be ready for later use. Riverpod providers are perfect fit for this job. For example:</p><pre><code><div class="highlight"><span></span><span class="c1">// A regular provider for accessing a dependency that is initialized *synchronously*</span>
<span class="nd">@Riverpod</span><span class="p">(</span><span class="nl">keepAlive:</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="n">FirebaseAuth</span><span class="w"> </span><span class="n">firebaseAuth</span><span class="p">(</span><span class="n">FirebaseAuthRef</span><span class="w"> </span><span class="n">ref</span><span class="p">)</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">FirebaseAuth</span><span class="p">.</span><span class="n">instance</span><span class="p">;</span>
</div></code></pre><p>For dependencies that need <strong>asynchronous</strong> initialization, such asÂ <code>SharedPreferences</code>, you can use aÂ <code>FutureProvider</code>:</p><pre><code><div class="highlight"><span></span><span class="c1">// A FutureProvider for accessing a dependency that is initialized *asynchronously*</span>
<span class="nd">@Riverpod</span><span class="p">(</span><span class="nl">keepAlive:</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="n">Future</span><span class="o">&lt;</span><span class="n">SharedPreferences</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sharedPreferences</span><span class="p">(</span><span class="n">SharedPreferencesRef</span><span class="w"> </span><span class="n">ref</span><span class="p">)</span>
<span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">SharedPreferences</span><span class="p">.</span><span class="n">getInstance</span><span class="p">();</span><span class="w"> </span><span class="c1">// returns a Future</span>
</div></code></pre><p>Here, we want the dependency to be initialized as soon as the app starts.</p><p>But keep in mind, Riverpod providers are <strong>lazily initialized by default</strong>â€”they are built when first used, <strong>not</strong> when declared. And the documentation says that if we want to <strong>eagerly initialize</strong> a provider, we can do so <a href="https://riverpod.dev/docs/essentials/eager_initialization">with a child widget</a>.</p><blockquote><p>Note how Iâ€™ve used <code>keepAlive: true</code> in the declarations above. This makes sense for dependencies that are initialized only once, during app startup.</p></blockquote><h3><a id="eager-provider-initialization-with-a-child-widget" href="#eager-provider-initialization-with-a-child-widget">Eager Provider Initialization with a Child Widget</a></h3><p>Letâ€™s take it a step further and create a customÂ <code>appStartupProvider</code>Â that centralizes all asynchronous initialization:</p><pre><code><div class="highlight"><span></span><span class="nd">@Riverpod</span><span class="p">(</span><span class="nl">keepAlive:</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">appStartup</span><span class="p">(</span><span class="n">Ref</span><span class="w"> </span><span class="n">ref</span><span class="p">)</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ref</span><span class="p">.</span><span class="n">onDispose</span><span class="p">(()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ensure we invalidate all the providers we depend on</span>
<span class="w">    </span><span class="n">ref</span><span class="p">.</span><span class="n">invalidate</span><span class="p">(</span><span class="n">sharedPreferencesProvider</span><span class="p">);</span>
<span class="w">  </span><span class="p">});</span>
<span class="w">  </span><span class="c1">// all asynchronous app initialization code should belong here:</span>
<span class="w">  </span><span class="kd">await</span><span class="w"> </span><span class="n">ref</span><span class="p">.</span><span class="n">watch</span><span class="p">(</span><span class="n">sharedPreferencesProvider</span><span class="p">.</span><span class="n">future</span><span class="p">);</span>
<span class="p">}</span>
</div></code></pre><p>Key points:</p><ol><li><strong>Dependency handling</strong>: We eagerly initialize theÂ <code>sharedPreferencesProvider</code>Â by awaiting itsÂ <code>.future</code>. This trick is <a href="https://github.com/bizz84/flutter-tips-and-tricks/blob/main/tips/0110-riverpod-watch-future-provider/index.md">explained here</a>.</li><li><strong>Cleanup</strong>: TheÂ <code>onDispose</code>Â callback invalidates theÂ <code>sharedPreferencesProvider</code>Â when theÂ <code>appStartupProvider</code>Â is invalidated.</li></ol><p>Now, letâ€™s update theÂ <code>AppStartupWidget</code>Â to use this provider:</p><pre><code><div class="highlight"><span></span><span class="c1">/// Widget class to manage asynchronous app initialization</span>
<span class="kd">class</span><span class="w"> </span><span class="nc">AppStartupWidget</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">ConsumerWidget</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">AppStartupWidget</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kd">required</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">onLoaded</span><span class="p">});</span>
<span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">WidgetBuilder</span><span class="w"> </span><span class="n">onLoaded</span><span class="p">;</span>

<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="n">Widget</span><span class="w"> </span><span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">WidgetRef</span><span class="w"> </span><span class="n">ref</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 2. eagerly initialize appStartupProvider (and all the providers it depends on)</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">appStartupState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref</span><span class="p">.</span><span class="n">watch</span><span class="p">(</span><span class="n">appStartupProvider</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">appStartupState</span><span class="p">.</span><span class="n">when</span><span class="p">(</span>
<span class="w">      </span><span class="c1">// 3. loading state</span>
<span class="w">      </span><span class="nl">loading:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">AppStartupLoadingWidget</span><span class="p">(),</span>
<span class="w">      </span><span class="c1">// 4. error state</span>
<span class="w">      </span><span class="nl">error:</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">st</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">AppStartupErrorWidget</span><span class="p">(</span>
<span class="w">        </span><span class="nl">message:</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">toString</span><span class="p">(),</span>
<span class="w">        </span><span class="c1">// 5. invalidate the appStartupProvider</span>
<span class="w">        </span><span class="nl">onRetry:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ref</span><span class="p">.</span><span class="n">invalidate</span><span class="p">(</span><span class="n">appStartupProvider</span><span class="p">),</span>
<span class="w">      </span><span class="p">),</span>
<span class="w">      </span><span class="c1">// 6. success - now load the main app</span>
<span class="w">      </span><span class="nl">data:</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">onLoaded</span><span class="p">(</span><span class="n">context</span><span class="p">),</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Finally, simplify theÂ <code>main()</code>Â method:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 1. load it when the app starts</span>
<span class="w">  </span><span class="n">runApp</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ProviderScope</span><span class="p">(</span>
<span class="w">    </span><span class="nl">child:</span><span class="w"> </span><span class="n">MaterialApp</span><span class="p">(</span>
<span class="w">      </span><span class="nl">home:</span><span class="w"> </span><span class="n">AppStartupWidget</span><span class="p">(</span>
<span class="w">        </span><span class="nl">onLoaded:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">MainApp</span><span class="p">(),</span>
<span class="w">      </span><span class="p">),</span>
<span class="w">    </span><span class="p">),</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</div></code></pre><h3><a id="how-it-works" href="#how-it-works">How It Works</a></h3><ol><li><strong>Application Startup</strong>: When the app starts,Â <code>AppStartupWidget</code>Â is loaded.</li><li><strong>Eager Initialization</strong>: TheÂ <code>appStartupProvider</code>Â is eagerly initialized, along with all its dependencies (e.g.,Â <code>sharedPreferencesProvider</code>).</li><li><strong>Loading State</strong>: While the provider is in aÂ <code>loading</code>Â state, we display theÂ <code>AppStartupLoadingWidget</code>.</li><li><strong>Error Handling</strong>: If initialization fails, theÂ <code>AppStartupErrorWidget</code>Â is displayed with an option to retry.</li><li><strong>Retry Logic</strong>: On retry, we invalidate theÂ <code>appStartupProvider</code>, triggering re-initialization.</li><li><strong>Success State</strong>: Once initialization succeeds, theÂ <code>onLoaded</code>Â callback is triggered, and theÂ <code>MainApp</code>Â widget takes the stage.</li></ol><h3><a id="accessing-eagerly-initialized-providers-with-requirevalue" href="#accessing-eagerly-initialized-providers-with-requirevalue">Accessing Eagerly-Initialized Providers with requireValue</a></h3><p>OnceÂ <code>MainApp</code>Â is loaded, we can safely assume that theÂ <code>sharedPreferencesProvider</code>Â isÂ <strong>fully initialized</strong>. This allows us to access its value directly usingÂ <code>requireValue</code>:</p><pre><code><div class="highlight"><span></span><span class="nd">@override</span>
<span class="n">Widget</span><span class="w"> </span><span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">WidgetRef</span><span class="w"> </span><span class="n">ref</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">sharedPrefs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref</span><span class="p">.</span><span class="n">watch</span><span class="p">(</span><span class="n">sharedPreferencesProvider</span><span class="p">).</span><span class="n">requireValue</span><span class="p">;</span>
<span class="p">}</span>
</div></code></pre><p>By usingÂ <code>requireValue</code>, you're essentially saying:Â <em>"I know this provider was initialized asynchronously, but at this point, it is guaranteed to have a value."</em></p><p>This works seamlessly because theÂ <code>sharedPreferencesProvider</code>Â (aÂ <code>FutureProvider</code>) was <strong>eagerly initialized</strong>Â beforeÂ <code>MainApp</code>Â was loaded. As a result, every descendant widget ofÂ <code>MainApp</code>Â can access it without additional checks.</p><figure><picture><source srcset="images/widgets-and-providers.webp 2x" type="image/webp"/><img class="bottom-12px" alt="Diagram showing the main widgets and providers" srcset="images/widgets-and-providers.png 2x"/></picture><figcaption><center><i>Diagram showing the main widgets and providers</i></center></figcaption></figure><blockquote><p>Heads-up: If you try to access <code>requireValue</code> on a provider that isn't ready yet, you'll hit an exception. If that happens, it's time to debug and revisit your assumptions.</p></blockquote><h2><a id="important-note-about-url-navigation-and-deep-links" href="#important-note-about-url-navigation-and-deep-links">Important Note About URL Navigation and Deep Links</a></h2><p>So far, we've seen how to eagerly initialize dependencies by placing an <code>AppStartupWidget</code> at the top of the widget tree. However, things get trickier when your app needs to supportÂ <strong>URL navigation</strong>Â orÂ <a href="/articles/flutter-deep-links/"><strong>deep links</strong></a>.</p><p>Why? Because apps that rely on URL-based navigation typically use aÂ <code>MaterialApp.router</code>Â with aÂ <code>GoRouter</code>Â (or equivalent) for routing. Unfortunately, theÂ <code>AppStartupWidget</code>Â doesnâ€™t handle this requirementâ€”it only manages app initialization.</p><h3><a id="the-solution-introducingÂ a-rootappwidget" href="#the-solution-introducingÂ a-rootappwidget">The Solution: IntroducingÂ a RootAppWidget</a></h3><p>To support URL navigation and deep links, we can introduce a top-levelÂ <code>RootAppWidget</code>Â that configures the router while still handling app startup. Hereâ€™s how:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">runApp</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ProviderScope</span><span class="p">(</span>
<span class="w">    </span><span class="c1">// * Use RootAppWidget, not AppStartupWidget</span>
<span class="w">    </span><span class="nl">child:</span><span class="w"> </span><span class="n">RootAppWidget</span><span class="p">(),</span>
<span class="w">  </span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">class</span><span class="w"> </span><span class="nc">RootAppWidget</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">ConsumerWidget</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">RootAppWidget</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">});</span>

<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="n">Widget</span><span class="w"> </span><span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">WidgetRef</span><span class="w"> </span><span class="n">ref</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">goRouter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref</span><span class="p">.</span><span class="n">watch</span><span class="p">(</span><span class="n">goRouterProvider</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">MaterialApp</span><span class="p">.</span><span class="n">router</span><span class="p">(</span>
<span class="w">      </span><span class="nl">routerConfig:</span><span class="w"> </span><span class="n">goRouter</span><span class="p">,</span>
<span class="w">      </span><span class="nl">builder:</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">child</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">AppStartupWidget</span><span class="p">(</span>
<span class="w">          </span><span class="nl">onLoaded:</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">child</span><span class="o">!</span><span class="p">,</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">      </span><span class="p">},</span>
<span class="w">      </span><span class="p">...,</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</div></code></pre><h3><a id="how-it-works" href="#how-it-works">How It Works</a></h3><p>With this setup, the <code>GoRouter</code> instance is initialized as soon as <code>runApp</code> is called. This ensures your app can <strong>process deep links and URL navigation immediately</strong>.</p><p><strong>But there's one trick!</strong> Can you spot it?</p><p>TheÂ <code>MaterialApp.builder</code>Â is key to this setup. It allows us to wrap the routerâ€™sÂ <code>child</code>Â widget with theÂ <code>AppStartupWidget</code>Â without interfering with the routing logic. This ensures that:</p><ul><li>The app startup logic runs before the main app UI loads.</li><li>Deep links and URL-based navigation are processed correctly from the start.</li></ul><h3><a id="real-world-example" href="#real-world-example">Real-World Example</a></h3><p>Here's a demo from my <a href="https://github.com/bizz84/starter_architecture_flutter_firebase">Time Tracker app</a>, where I test URL-based navigation with an artificial delay of one second during app startup:</p><figure><picture><img class="bottom-12px" alt="App startup loading animation for my Time Tracker app" srcset="images/app-startup-loading.gif 2x"/></picture><figcaption><center><i>App startup loading animation for my Time Tracker app</i></center></figcaption></figure><p>This setup works very well in practice, so let's summarize how everything ties together.</p><h2><a id="summary-stateful-app-initialization-with-router" href="#summary-stateful-app-initialization-with-router">Summary: Stateful App Initialization with Router</a></h2><p>Hereâ€™s a diagram that captures the final setup:</p><figure><picture><source srcset="images/widgets-and-providers-router.webp 2x" type="image/webp"/><img class="bottom-12px" alt="Diagram showing the main widgets and providers in combination with the MaterialApp.router API" srcset="images/widgets-and-providers-router.png 2x"/></picture><figcaption><center><i>Diagram showing the main widgets and providers in combination with the MaterialApp.router API</i></center></figcaption></figure><p>To achieve a robust app initialization process with URL navigation and deep-link support, we need three key components:</p><ol><li><strong><code>MaterialApp.router</code></strong>: Configured withÂ <code>GoRouter</code>Â (or an equivalent declarative routing solution) to handle URL navigation and deep links.</li><li><strong><code>AppStartupWidget</code></strong>: Wrapped inÂ <code>MaterialApp.builder</code>Â to manage the appâ€™s initialization flow while deferring to the router's child widget once initialization is complete.</li><li><strong><code>appStartupProvider</code></strong>: AÂ <code>FutureProvider</code>Â that <strong>eagerly initializes</strong> all asynchronous dependencies required during app startup.</li></ol><p>By layering these components, weâ€™ve created a production-ready solution thatâ€™s flexible enough to handle both complex routing and robust dependency handling.</p><h2><a id="common-questions" href="#common-questions">Common Questions</a></h2><p>Now that weâ€™ve covered the essentials, letâ€™s address some common questions you might have.</p><h3><a id="how-to-eagerly-initialize-multiple-providers?" href="#how-to-eagerly-initialize-multiple-providers?">How to Eagerly Initialize Multiple Providers?</a></h3><p>If your app requires multiple dependencies to be initialized upfront, the <code>appStartupProvider</code> is the perfect place to manage them:</p><pre><code><div class="highlight"><span></span><span class="nd">@Riverpod</span><span class="p">(</span><span class="nl">keepAlive:</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">appStartup</span><span class="p">(</span><span class="n">AppStartupRef</span><span class="w"> </span><span class="n">ref</span><span class="p">)</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// all asynchronous app initialization code should belong here:</span>
<span class="w">  </span><span class="kd">await</span><span class="w"> </span><span class="n">ref</span><span class="p">.</span><span class="n">watch</span><span class="p">(</span><span class="n">sharedPreferencesProvider</span><span class="p">.</span><span class="n">future</span><span class="p">);</span>
<span class="w">  </span><span class="kd">await</span><span class="w"> </span><span class="n">ref</span><span class="p">.</span><span class="n">watch</span><span class="p">(</span><span class="n">sembastDatabaseProvider</span><span class="p">.</span><span class="n">future</span><span class="p">);</span>
<span class="p">}</span>
</div></code></pre><p>If the dependencies are <strong>independent of each other</strong>, you can even useÂ <code>Future.wait</code>Â to initialize them concurrently. This can save precious milliseconds during startup:</p><pre><code><div class="highlight"><span></span><span class="nd">@Riverpod</span><span class="p">(</span><span class="nl">keepAlive:</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">appStartup</span><span class="p">(</span><span class="n">AppStartupRef</span><span class="w"> </span><span class="n">ref</span><span class="p">)</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// await for all initialization code to be complete before returning</span>
<span class="w">  </span><span class="kd">await</span><span class="w"> </span><span class="n">Future</span><span class="p">.</span><span class="n">wait</span><span class="p">([</span>
<span class="w">    </span><span class="n">ref</span><span class="p">.</span><span class="n">watch</span><span class="p">(</span><span class="n">sharedPreferencesProvider</span><span class="p">.</span><span class="n">future</span><span class="p">),</span>
<span class="w">    </span><span class="n">ref</span><span class="p">.</span><span class="n">watch</span><span class="p">(</span><span class="n">onboardingRepositoryProvider</span><span class="p">.</span><span class="n">future</span><span class="p">)</span>
<span class="w">  </span><span class="p">]);</span>
<span class="p">}</span>
</div></code></pre><h3><a id="what-about-programmer-or-configuration-errors?" href="#what-about-programmer-or-configuration-errors?">What About Programmer or Configuration Errors?</a></h3><p>When it comes to dependency initialization, consider the type of failure youâ€™re handling:</p><ul><li>If initialization might fail due toÂ <strong>unexpected runtime errors</strong>Â (e.g., network issues, missing permissions), it makes sense to handle it inÂ <code>appStartup</code>Â so you can recover gracefully.</li><li>If initialization can only fail because of aÂ <strong>programmer or configuration error</strong>, itâ€™s better to perform it directly inÂ <code>main</code>. Why? Because such errors are typically non-recoverable and should be caught and fixed during development.</li></ul><p>A classic example is Firebase initialization, which is prone to configuration errors if not set up correctly:</p><pre><code><div class="highlight"><span></span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">WidgetsFlutterBinding</span><span class="p">.</span><span class="n">ensureInitialized</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// * Initialize Firebase</span>
<span class="w">  </span><span class="kd">await</span><span class="w"> </span><span class="n">Firebase</span><span class="p">.</span><span class="n">initializeApp</span><span class="p">(</span><span class="nl">options:</span><span class="w"> </span><span class="n">DefaultFirebaseOptions</span><span class="p">.</span><span class="n">currentPlatform</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// * Entry point of the app</span>
<span class="w">  </span><span class="n">runApp</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ProviderScope</span><span class="p">(</span>
<span class="w">    </span><span class="nl">child:</span><span class="w"> </span><span class="n">MainApp</span><span class="p">(),</span>
<span class="w">  </span><span class="p">));</span>
<span class="p">}</span>
</div></code></pre><p>By keeping this code inÂ <code>main</code>, any configuration issues (e.g., missing or misconfiguredÂ <code>google-services.json</code>Â orÂ <code>GoogleService-Info.plist</code>) will surface immediately during development, allowing you to quickly identify and fix them.</p><h3><a id="how-to-implement-the-retry-logic?" href="#how-to-implement-the-retry-logic?">How to Implement the Retry Logic?</a></h3><p>When dealing with complex initialization logic, itâ€™s often necessary to allow users to <strong>retry</strong> if something goes wrong. To achieve this, we can enhance the <code>appStartupProvider</code> by converting it into a <code>Notifier</code> with a <code>retry()</code> method:</p><pre><code><div class="highlight"><span></span><span class="nd">@riverpod</span>
<span class="kd">class</span><span class="w"> </span><span class="nc">AppStartupNotifier</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">_$AppStartupNotifier</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">build</span><span class="p">()</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Initially, load the database from JSON</span>
<span class="w">    </span><span class="kd">await</span><span class="w"> </span><span class="n">_complexInitializationLogic</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">_complexInitializationLogic</span><span class="p">()</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// some complex initialization logic    </span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">retry</span><span class="p">()</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// use AsyncValue.guard to handle errors gracefully</span>
<span class="w">    </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">await</span><span class="w"> </span><span class="n">AsyncValue</span><span class="p">.</span><span class="n">guard</span><span class="p">(</span><span class="n">_complexInitializationLogic</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Accordingly, the <code>AppStartupWidget</code> can be updated to call the <code>retry</code> method from the <code>onRetry</code> callback:</p><pre><code><div class="highlight"><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">AppStartupWidget</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">ConsumerWidget</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">AppStartupWidget</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kd">required</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">onLoaded</span><span class="p">});</span>
<span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">WidgetBuilder</span><span class="w"> </span><span class="n">onLoaded</span><span class="p">;</span>

<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="n">Widget</span><span class="w"> </span><span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">WidgetRef</span><span class="w"> </span><span class="n">ref</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 1. eagerly initialize appStartupProvider (and all the providers it depends on)</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">appStartupState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref</span><span class="p">.</span><span class="n">watch</span><span class="p">(</span><span class="n">appStartupNotifierProvider</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">appStartupState</span><span class="p">.</span><span class="n">when</span><span class="p">(</span>
<span class="w">      </span><span class="c1">// 2. loading state</span>
<span class="w">      </span><span class="nl">loading:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">AppStartupLoadingWidget</span><span class="p">(),</span>
<span class="w">      </span><span class="c1">// 3. error state</span>
<span class="w">      </span><span class="nl">error:</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">st</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">AppStartupErrorWidget</span><span class="p">(</span>
<span class="w">          </span><span class="nl">message:</span>
<span class="w">              </span><span class="s1">&#39;Could not load or sync data. Check your Internet connection and retry or contact support if the issue persists.&#39;</span><span class="p">,</span>
<span class="w">          </span><span class="c1">// 4. retry logic</span>
<span class="w">          </span><span class="nl">onRetry:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">await</span><span class="w"> </span><span class="n">ref</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">appStartupNotifierProvider</span><span class="p">.</span><span class="n">notifier</span><span class="p">).</span><span class="n">retry</span><span class="p">();</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">      </span><span class="p">},</span>
<span class="w">      </span><span class="c1">// 5. success - now load the main app</span>
<span class="w">      </span><span class="nl">data:</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">onLoaded</span><span class="p">(</span><span class="n">context</span><span class="p">),</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</div></code></pre><h3><a id="can-any-provider-be-eagerly-initialized?" href="#can-any-provider-be-eagerly-initialized?">Can Any Provider be Eagerly Initialized?</a></h3><p>No, not all providers should be eagerly initialized.</p><p>TheÂ <code>appStartupProvider</code>Â is specifically designed for initializingÂ <strong>asynchronous dependencies</strong>Â that remain constant throughout the app's lifecycle. Examples include shared preferences, database connections, or configuration files.</p><p>Providers that may change state over time (e.g., user authentication status or real-time data streams) shouldÂ <strong>not</strong>Â be eagerly initialized. Doing so could lead to unwanted rebuilds or performance issues, as their state updates dynamically after the app has started.</p><h3><a id="how-to-transition-between-the-splash-loading-and-main-ui-screens?" href="#how-to-transition-between-the-splash-loading-and-main-ui-screens?">How to Transition Between the Splash, Loading, and Main UI Screens?</a></h3><p>By default, a Flutter app shows aÂ <strong>native splash screen</strong>Â untilÂ <code>runApp</code>Â is called. You can configure this splash screen using a package likeÂ <a href="https://pub.dev/packages/flutter_native_splash">flutter_native_splash</a>.</p><p>To ensure a smooth transition between the splash screen, loading UI, and the main app UI:</p><ol><li><strong>Match the Styles</strong>: Customize your Flutter loading screen to visually match the native splash screen, creating the illusion of continuity.</li><li><strong>Add Transitions</strong>: Overlay the loading screen with subtle animations or progress indicators to keep users engaged.</li><li><strong>Animate Into the Main UI</strong>: Once initialization is complete, use a fade, slide, or scale animation to transition from the loading screen to the main app UI.</li></ol><p>This approach ensures a polished, professional user experience while minimizing jarring transitions during app startup.</p><h3><a id="can-i-use-provider-overrides-as-a-simpler-alternative-for-asynchronous-initialization?" href="#can-i-use-provider-overrides-as-a-simpler-alternative-for-asynchronous-initialization?">Can I Use Provider Overrides as a Simpler Alternative for Asynchronous Initialization?</a></h3><p>The old way of doing things was to declare a normal provider that throws an <code>UnimplementedError</code> by default:</p><pre><code><div class="highlight"><span></span><span class="nd">@Riverpod</span><span class="p">(</span><span class="nl">keepAlive:</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span>
<span class="n">SharedPreferences</span><span class="w"> </span><span class="n">sharedPreferences</span><span class="p">(</span><span class="n">SharedPreferencesRef</span><span class="w"> </span><span class="n">ref</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">UnimplementedError</span><span class="p">();</span>
</div></code></pre><p>Then, in the <code>main</code> function, we'd override the provider with its initialized value:</p><pre><code><div class="highlight"><span></span><span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">sharedPreferences</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">await</span><span class="w"> </span><span class="n">SharedPreferences</span><span class="p">.</span><span class="n">getInstance</span><span class="p">();</span>
<span class="w">  </span><span class="n">runApp</span><span class="p">(</span><span class="n">ProviderScope</span><span class="p">(</span>
<span class="w">    </span><span class="nl">overrides:</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="n">sharedPreferencesProvider</span><span class="p">.</span><span class="n">overrideWithValue</span><span class="p">(</span><span class="n">sharedPreferences</span><span class="p">)</span>
<span class="w">    </span><span class="p">],</span>
<span class="w">    </span><span class="nl">child:</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">MainApp</span><span class="p">(),</span>
<span class="w">  </span><span class="p">));</span>
<span class="p">}</span>
</div></code></pre><p>This method effectively injects pre-initialized dependencies into the <code>ProviderScope</code> before the app starts.</p><p><strong>When Should You Use This Approach?</strong></p><p>If youâ€™re working with an <strong>older codebase</strong>, you might encounter this patternâ€”or variants that use <code>ProviderContainer</code> and <code>UncontrolledProviderScope</code> for eager initialization. While it works, it has limitations:</p><ol><li><strong>No Retry Capability</strong>: If the initialization fails (e.g., due to a runtime error), thereâ€™s no built-in mechanism to retry or recover gracefully.</li><li><strong>Error Handling</strong>: It assumes that initialization will always succeed, which might not be a safe assumption for all dependencies.</li></ol><p><strong>Should You Still Use It?</strong></p><p>This approach is fine if you're <strong>100% confident</strong> that the initialization will always succeed. Dependencies like <code>SharedPreferences</code> or static configuration files are good candidates because they rarely fail in production.</p><blockquote><p>In this article, I only used <code>SharedPreferences</code> as an example for illustration purposes. In practice, it's ok to asynchronously initialize <code>SharedPreferences</code> inside <code>main()</code>.</p></blockquote><p>However, if thereâ€™s any chance of failure (e.g., network-based initialization, database migrations), the stateful <code>AppStartupWidget</code> approach is a better choice. It provides more flexibility for error handling, retries, and user feedback during app startup.</p><h2><a id="conclusion" href="#conclusion">Conclusion</a></h2><p>A smooth and delightful onboarding experience is your chance to impress your users and set the tone for your app. To achieve this, your app startup logic needs to be <strong>robust</strong>, handle errors gracefully, and provide a seamless transition into the main app.</p><p>Hereâ€™s a quick recap of the techniques we covered:</p><ul><li>Use an <code>appStartupProvider</code> to initialize all asynchronous dependencies, leveraging <code>await</code> and <code>.future</code>.</li><li>Eagerly initialize the <code>appStartupProvider</code> inside a top-level <code>AppStartupWidget</code> and use <code>requireValue</code> to access asynchronously initialized dependencies once they are guaranteed to be ready.</li><li>Provide a <strong>loading UI</strong>, handle errors gracefully, and include a retry mechanism for recoverable failures.</li><li>For apps with <strong>URL navigation or deep-linking</strong>, integrate your <code>AppStartupWidget</code> within <code>MaterialApp.builder</code> to support declarative routing while managing startup logic.</li></ul><p>Thatâ€™s it! You now have a repeatable process for writing robust app startup code.</p><h3><a id="real-world-example" href="#real-world-example">Real-World Example</a></h3><p>Looking for a practical implementation? Check out my <a href="https://github.com/bizz84/starter_architecture_flutter_firebase">time-tracking app on GitHub</a>, where Iâ€™ve applied these concepts to a real-world project.</p><h3><a id="whatâ€™s-next?" href="#whatâ€™s-next?">Whatâ€™s Next?</a></h3><p>While weâ€™ve covered the essentials of app startup logic, thereâ€™s still more to explore. For instance, we havenâ€™t discussed <strong>error monitoring</strong> or <strong>crash reporting</strong>, which are critical for identifying and resolving issues in production. I dive deeper into these topics (and more) in my latest course. ğŸ‘‡</p><h2><a id="new-course-flutter-in-production" href="#new-course-flutter-in-production">New Course: Flutter in Production</a></h2><p>When it comes to <strong>shipping</strong> and <strong>maintaining</strong> apps in production, there are many important aspects to consider:</p><ul><li><strong>Preparing for release</strong>: splash screens, flavors, environments, error reporting, analytics, force update, privacy, T&amp;Cs</li><li><strong>App Submissions</strong>: app store metadata &amp; screenshots, compliance, testing vs distribution tracks, dealing with rejections</li><li><strong>Release automation:</strong> CI workflows, environment variables, custom build steps, code signing, uploading to the stores</li><li><strong>Post-release</strong>: error monitoring, bug fixes, addressing user feedback, adding new features, over-the-air updates</li></ul><p>My latest course will help you get your app to the stores faster and with fewer headaches.</p><p>If youâ€™re interested, you can learn more and enroll here. ğŸ‘‡</p></div><div class="centered-card-container"><a class="card plausible-event-name=Click+Card+FF3" href="/courses/flutter-in-production/"><article><figure><picture><source srcset="/img/banners/flutter-in-production-course-banner.avif" type="image/avif"/><source srcset="/img/banners/flutter-in-production-course-banner.webp" type="image/webp"/><img alt="Flutter In Production" loading="lazy" src="/img/banners/flutter-in-production-course-banner.png"/></picture></figure><div class="card-content"><h3>Flutter In Production</h3><div class="card-content-info"><span>INTERMEDIATE TO ADVANCED</span></div><p>Learn about flavors, environments, error monitoring, analytics, release management, CI/CD, and finally ship your Flutter apps to the stores. ğŸš€</p></div></article></a></div></article><aside><div class="widget js-widget-table-of-contents"></div><div class="widget widget-newsletter"><h3>Never miss my articles &amp; newsletters</h3><p>Join 22K+ Flutter developers who get my latest tips, articles, and hand-picked Flutter resources:</p><form id="form-newsletterContentSidebar" action="https://app.convertkit.com/forms/3584409/subscriptions" method="post" novalidate="true" data-sv-form="3584409" data-uid="64c4f3ed27"><input name="email_address" type="email" required="true" placeholder="Your Email Address" aria-label="Your Email Address"/><button type="submit">Subscribe</button></form><script>trackEmailSignup("form-newsletterContentSidebar", "contentSidebar", "articles/robust-app-initialization-riverpod", "Signup New Newsletter")</script></div></aside></div></main><section class="cards mb-x2"><header><h2>Want More?</h2><p class="cards-description">Invest in yourself with my high-quality Flutter courses.</p></header><div class="cards-list col-2"><a class="card plausible-event-name=Click+Card+FF1" href="/courses/flutter-foundations/"><article><figure><picture><source srcset="/img/banners/flutter-foundations-small.avif" type="image/avif"/><source srcset="/img/banners/flutter-foundations-small.webp" type="image/webp"/><img alt="Flutter Foundations Course" loading="lazy" src="/img/banners/flutter-foundations-small.png"/></picture></figure><div class="card-content"><h3>Flutter Foundations Course</h3><div class="card-content-info"><span>INTERMEDIATE TO ADVANCED</span></div><p>Learn about State Management, App Architecture, Navigation, Testing, and much more by building a Flutter eCommerce app on iOS, Android, and web.</p></div></article></a><a class="card plausible-event-name=Click+Card+FF2" href="/courses/flutter-firebase-masterclass/"><article><figure><picture><source srcset="/img/banners/flutter-firebase-course-banner-small.avif" type="image/avif"/><source srcset="/img/banners/flutter-firebase-course-banner-small.webp" type="image/webp"/><img alt="Flutter & Firebase Masterclass" loading="lazy" src="/img/banners/flutter-firebase-course-banner-small.png"/></picture></figure><div class="card-content"><h3>Flutter &amp; Firebase Masterclass</h3><div class="card-content-info"><span>INTERMEDIATE TO ADVANCED</span></div><p>Learn about Firebase Auth, Cloud Firestore, Cloud Functions, Stripe payments, and much more by building a full-stack eCommerce app with Flutter &amp; Firebase.</p></div></article></a><a class="card plausible-event-name=Click+Card+Dart" href="/courses/complete-dart-guide/"><article><figure><picture><source srcset="/img/banners/dart-course-banner-small.avif" type="image/avif"/><source srcset="/img/banners/dart-course-banner-small.webp" type="image/webp"/><img alt="The Complete Dart Developer Guide" loading="lazy" src="/img/banners/dart-course-banner-small.png"/></picture></figure><div class="card-content"><h3>The Complete Dart Developer Guide</h3><div class="card-content-info"><span>BEGINNER</span></div><p>Learn Dart Programming in depth. Includes: basic to advanced topics, exercises, and projects. Last updated to Dart 2.15.</p></div></article></a><a class="card plausible-event-name=Click+Card+FA" href="/courses/flutter-animations-masterclass/"><article><figure><picture><source srcset="/img/banners/flutter-animations-course-banner-small.avif" type="image/avif"/><source srcset="/img/banners/flutter-animations-course-banner-small.webp" type="image/webp"/><img alt="Flutter Animations Masterclass" loading="lazy" src="/img/banners/flutter-animations-course-banner-small.png"/></picture></figure><div class="card-content"><h3>Flutter Animations Masterclass</h3><div class="card-content-info"><span>INTERMEDIATE</span></div><p>Master Flutter animations and build a completely custom habit tracking application.</p></div></article></a></div></section><footer id="footer"><a class="logo" href="/"><img src="/img/icons/logo.svg" alt="Code with Andrea"/><span>CODE WITH ANDREA</span></a><p>Copyright Â© 2020-present Coding With Flutter Limited</p><nav><a href="/contact/">Contact</a><a href="https://twitter.com/biz84" rel="noopener noreferrer" target="_blank">Twitter</a><a href="https://nnbd.me/discord" rel="noopener noreferrer" target="_blank">Discord</a><a href="https://github.com/bizz84/" rel="noopener" target="_blank">GitHub</a><a href="/rss.xml">RSS</a><a href="/meta/">Meta</a><a href="/privacy-policy/">Privacy Policy</a><a href="/terms-of-use/">Terms of Use</a></nav></footer><script src="/js/widget-table-of-contents.min.js"></script><script src="/js/global.min.js"></script><script src="/js/menu-toggle.min.js"></script><script src="/js/countdown.min.js"></script><script src="/js/light-youtube-embed.min.js"></script></body></html>